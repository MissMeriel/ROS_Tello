<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs == param1.header.stamp.secs</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.stamp.secs == param1.header.stamp.secs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs == param1.header.stamp.nsecs</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.stamp.nsecs == param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 has only one value</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0 has only one value</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq == 91406</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.seq == 91406</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y == 0.036634994176</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.rotation.y == 0.036634994176</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z == -0.114680339222</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.rotation.z == -0.114680339222</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs == 1550026776</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.stamp.secs == 1550026776</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z == 0.0274019080203</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.translation.z == 0.0274019080203</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs == 658556068</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.header.stamp.nsecs == 658556068</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x == -0.0319398802488</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.translation.x == -0.0319398802488</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y == -1.3247817639</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.translation.y == -1.3247817639</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x == 0.0862098886482</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.rotation.x == 0.0862098886482</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w == 0.988976315236</INV> <SAMPLES>2</SAMPLES> <DAIKON>param0.transform.rotation.w == 0.988976315236</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 has only one value</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1 has only one value</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.header.seq == 108914</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.header.seq == 108914</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y == 0.176409390523</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.rotation.y == 0.176409390523</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z == 0.915590984823</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.rotation.z == 0.915590984823</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z == 0.5957079971</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.translation.z == 0.5957079971</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x == -0.227046471721</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.translation.x == -0.227046471721</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.y == 0.148933136207</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.translation.y == 0.148933136207</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x == -0.0111552665548</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.rotation.x == -0.0111552665548</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.361176460299</INV> <SAMPLES>2</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.361176460299</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return has only one value</INV> <SAMPLES>2</SAMPLES> <DAIKON>return has only one value</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data == false</INV> <SAMPLES>2</SAMPLES> <DAIKON>return.data == false</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w != 0</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param0.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.x != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != param1.transform.rotation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.z != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.z != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>1432</SAMPLES> <DAIKON>param1.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1432</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;GO TO GOAL&quot;, &quot;USER1 CONTROL&quot;, &quot;manual control&quot; }</INV> <SAMPLES>1432</SAMPLES> <DAIKON>return.data one of { &quot;GO TO GOAL&quot;, &quot;USER1 CONTROL&quot;, &quot;manual control&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 has only one value</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0 has only one value</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq == 91406</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.seq == 91406</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y == 0.036634994176</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.y == 0.036634994176</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z == -0.114680339222</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.z == -0.114680339222</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs == 1550026776</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.stamp.secs == 1550026776</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z == 0.0274019080203</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.z == 0.0274019080203</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs == 658556068</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.stamp.nsecs == 658556068</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x == -0.0319398802488</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.x == -0.0319398802488</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y == -1.3247817639</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.y == -1.3247817639</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x == 0.0862098886482</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.x == 0.0862098886482</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w == 0.988976315236</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.w == 0.988976315236</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != 0</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != 0</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x != 0</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != 0</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w != 0</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs &lt;= param1.header.stamp.secs</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.header.stamp.secs &lt;= param1.header.stamp.secs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != param1.transform.rotation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.z != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.z != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>695</SAMPLES> <DAIKON>param1.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>695</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>695</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z == 0.0</INV> <SAMPLES>695</SAMPLES> <DAIKON>return.linear.z == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>695</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.w</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.x</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != return.transform.rotation.w</INV> <SAMPLES>5718</SAMPLES> <DAIKON>return.transform.rotation.x != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.w</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.x</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.x</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.y</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != return.transform.translation.y</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.translation.x != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != return.transform.rotation.w</INV> <SAMPLES>5712</SAMPLES> <DAIKON>return.transform.rotation.x != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
