<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.header.seq one of { 216895, 218951 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.header.seq one of { 216895, 218951 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y one of { 0.0918162092041, 0.0944038417342 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.y one of { 0.0918162092041, 0.0944038417342 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z one of { 0.985664351163, 0.988769412816 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.z one of { 0.985664351163, 0.988769412816 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.header.stamp.secs one of { 1550027898, 1550027919 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.header.stamp.secs one of { 1550027898, 1550027919 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z one of { 0.517012153624, 0.517667905903 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.z one of { 0.517012153624, 0.517667905903 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.header.stamp.nsecs one of { 211042373, 370843041 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.header.stamp.nsecs one of { 211042373, 370843041 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x one of { -0.0960761294363, -0.0668197280067 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.x one of { -0.0960761294363, -0.0668197280067 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.y one of { 0.120417723704, 0.124737000526 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.y one of { 0.120417723704, 0.124737000526 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x one of { -0.0827695607013, -0.0782326653883 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.x one of { -0.0827695607013, -0.0782326653883 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w one of { 0.0882297119683, 0.112707148546 }</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.w one of { 0.0882297119683, 0.112707148546 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param0.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs &gt;= param1.header.stamp.secs</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.header.stamp.secs &gt;= param1.header.stamp.secs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param0.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &lt; param1.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.w &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>304</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>304</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data == false</INV> <SAMPLES>304</SAMPLES> <DAIKON>return.data == false</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param0.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs &gt;= param1.header.stamp.secs</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.header.stamp.secs &gt;= param1.header.stamp.secs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param0.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &lt; param1.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.w &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>128</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>128</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data == &quot;GO TO GOAL&quot;</INV> <SAMPLES>128</SAMPLES> <DAIKON>return.data == &quot;GO TO GOAL&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != 0</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w != 0</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param0.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param0.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &gt; param1.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.translation.y &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &lt; param1.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.w &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y != param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.y != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>431</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>431</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z one of { -200.0, 0.0 }</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.linear.z one of { -200.0, 0.0 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.y &lt;= return.linear.x</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.linear.y &lt;= return.linear.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.x &gt;= return.linear.z</INV> <SAMPLES>431</SAMPLES> <DAIKON>return.linear.x &gt;= return.linear.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &gt; return.transform.rotation.x</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.y &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.w</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>2170</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &gt; return.transform.rotation.z</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.y &gt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.x</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.y</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>2169</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
