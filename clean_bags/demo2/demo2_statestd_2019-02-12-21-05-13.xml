<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt;= 0.87728892588</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &lt;= 0.87728892588</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.UpperBoundFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt;= 0.0373743135057</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &gt;= 0.0373743135057</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.LowerBoundFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z one of { 0.336192066889, 0.336235849809 }</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z one of { 0.336192066889, 0.336235849809 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z one of { 1.05235948185, 1.05273480544 }</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z one of { 1.05235948185, 1.05273480544 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.941783160825</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.941783160825</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param0.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.62145527168E11 * param1.transform.rotation.y - 1.5147914076163E13 * param1.transform.rotation.w + 1.4267114627163E13 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.62145527168E11 * param1.transform.rotation.y - 1.5147914076163E13 * param1.transform.rotation.w + 1.4267114627163E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.2492758634E10 * param1.transform.rotation.z + 2.28945314917E11 * param1.transform.rotation.w - 2.43350266601E11 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>8.2492758634E10 * param1.transform.rotation.z + 2.28945314917E11 * param1.transform.rotation.w - 2.43350266601E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.252218626304E12 * param1.transform.rotation.x + 5.8350002546085E13 * param1.transform.rotation.w - 5.4959140956688E13 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.252218626304E12 * param1.transform.rotation.x + 5.8350002546085E13 * param1.transform.rotation.w - 5.4959140956688E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.829913736356919E15 * param0.transform.rotation.y + 2.209981293331235E15 * param0.transform.rotation.z + 3.6673417878622945E18 * param1.transform.rotation.w - 3.4539298551395113E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.829913736356919E15 * param0.transform.rotation.y + 2.209981293331235E15 * param0.transform.rotation.z + 3.6673417878622945E18 * param1.transform.rotation.w - 3.4539298551395113E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.142904620746211E15 * param0.transform.rotation.y - 6.58525241274498E14 * param0.transform.rotation.x + 4.5965047124663153E18 * param1.transform.rotation.w - 4.3288564478208338E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.142904620746211E15 * param0.transform.rotation.y - 6.58525241274498E14 * param0.transform.rotation.x + 4.5965047124663153E18 * param1.transform.rotation.w - 4.3288564478208338E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.516041227076307E15 * param0.transform.rotation.y - 7.071940138659952E16 * param0.transform.rotation.w + 1.4560855755346088E19 * param1.transform.rotation.w - 1.364256496340302E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>4.516041227076307E15 * param0.transform.rotation.y - 7.071940138659952E16 * param0.transform.rotation.w + 1.4560855755346088E19 * param1.transform.rotation.w - 1.364256496340302E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.001819935651841E15 * param0.transform.rotation.y - 3.2698671194131398E17 * param1.transform.rotation.y + 1.8894721073611047E19 * param1.transform.rotation.w - 1.7795949698894981E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>8.001819935651841E15 * param0.transform.rotation.y - 3.2698671194131398E17 * param1.transform.rotation.y + 1.8894721073611047E19 * param1.transform.rotation.w - 1.7795949698894981E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.899951930388985E15 * param0.transform.rotation.y + 1.0141621398406743E18 * param1.transform.rotation.x + 1.8195690462881835E19 * param1.transform.rotation.w - 1.7138214758003716E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.899951930388985E15 * param0.transform.rotation.y + 1.0141621398406743E18 * param1.transform.rotation.x + 1.8195690462881835E19 * param1.transform.rotation.w - 1.7138214758003716E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.142904620746211E15 * param0.transform.rotation.z - 9.1193397004549E14 * param0.transform.rotation.x - 5.568586657660119E18 * param1.transform.rotation.w + 5.2443128972957522E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.142904620746211E15 * param0.transform.rotation.z - 9.1193397004549E14 * param0.transform.rotation.x - 5.568586657660119E18 * param1.transform.rotation.w + 5.2443128972957522E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.516041227076307E15 * param0.transform.rotation.z + 9.0557239563421408E16 * param0.transform.rotation.w - 1.1151270412000745E19 * param1.transform.rotation.w + 1.0411487390082382E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>4.516041227076307E15 * param0.transform.rotation.z + 9.0557239563421408E16 * param0.transform.rotation.w - 1.1151270412000745E19 * param1.transform.rotation.w + 1.0411487390082382E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.001819935651841E15 * param0.transform.rotation.z + 2.61798925225863456E17 * param1.transform.rotation.y - 1.512788590137461E19 * param1.transform.rotation.w + 1.4247790192546546E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>8.001819935651841E15 * param0.transform.rotation.z + 2.61798925225863456E17 * param1.transform.rotation.y - 1.512788590137461E19 * param1.transform.rotation.w + 1.4247790192546546E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.899951930388985E15 * param0.transform.rotation.z - 8.1197965702869978E17 * param1.transform.rotation.x - 1.4568213425687796E19 * param1.transform.rotation.w + 1.372127907352481E19 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.899951930388985E15 * param0.transform.rotation.z - 8.1197965702869978E17 * param1.transform.rotation.x - 1.4568213425687796E19 * param1.transform.rotation.w + 1.372127907352481E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.623127929625839E15 * param0.transform.rotation.x + 6.8572947863878752E16 * param0.transform.rotation.w + 8.1330079959556014E18 * param1.transform.rotation.w - 7.7281486101076224E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.623127929625839E15 * param0.transform.rotation.x + 6.8572947863878752E16 * param0.transform.rotation.w + 8.1330079959556014E18 * param1.transform.rotation.w - 7.7281486101076224E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.001819935651841E15 * param0.transform.rotation.x - 1.68376410912383168E17 * param1.transform.rotation.y + 9.729524789179156E18 * param1.transform.rotation.w - 9.1640947196593142E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>8.001819935651841E15 * param0.transform.rotation.x - 1.68376410912383168E17 * param1.transform.rotation.y + 9.729524789179156E18 * param1.transform.rotation.w - 9.1640947196593142E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.899951930388985E15 * param0.transform.rotation.x + 5.2222605675866886E17 * param1.transform.rotation.x + 9.369570512585802E18 * param1.transform.rotation.w - 8.8253093229118536E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.899951930388985E15 * param0.transform.rotation.x + 5.2222605675866886E17 * param1.transform.rotation.x + 9.369570512585802E18 * param1.transform.rotation.w - 8.8253093229118536E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.36339109115949E14 * param1.transform.rotation.y - 1.9819318369656524E16 * param1.transform.rotation.z - 5.5112967310271864E16 * param1.transform.rotation.w + 5.8568903513785888E16 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.36339109115949E14 * param1.transform.rotation.y - 1.9819318369656524E16 * param1.transform.rotation.z - 5.5112967310271864E16 * param1.transform.rotation.w + 5.8568903513785888E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.9390871886768756E16 * param1.transform.rotation.y - 2.865069195388351E15 * param1.transform.rotation.x - 1.17682784403441936E17 * param1.transform.rotation.w + 1.10914264669782736E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.9390871886768756E16 * param1.transform.rotation.y - 2.865069195388351E15 * param1.transform.rotation.x - 1.17682784403441936E17 * param1.transform.rotation.w + 1.10914264669782736E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.75906156189649088E17 * param1.transform.rotation.z + 8.23465296093709E14 * param1.transform.rotation.x + 7.743608660061399E17 * param1.transform.rotation.w - 8.2203902720264538E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.75906156189649088E17 * param1.transform.rotation.z + 8.23465296093709E14 * param1.transform.rotation.x + 7.743608660061399E17 * param1.transform.rotation.w - 8.2203902720264538E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z one of { 0.336192066889, 0.336232115571 }</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.z one of { 0.336192066889, 0.336232115571 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z one of { 1.05223391605, 1.05235948185, 1.05270567857 }</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.translation.z one of { 1.05223391605, 1.05235948185, 1.05270567857 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.941783160825</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.941783160825</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param0.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.x != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.00568892736E11 * param1.transform.rotation.y + 6.796999621718E12 * param1.transform.rotation.w - 6.397686890533E12 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>9.00568892736E11 * param1.transform.rotation.y + 6.796999621718E12 * param1.transform.rotation.w - 6.397686890533E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.2173345334E10 * param1.transform.rotation.z + 2.37718885437E11 * param1.transform.rotation.w - 2.51505670126E11 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>8.2173345334E10 * param1.transform.rotation.z + 2.37718885437E11 * param1.transform.rotation.w - 2.51505670126E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.00505682432E11 * param1.transform.rotation.x - 4.7073610762607E13 * param1.transform.rotation.w + 4.4331471276077E13 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>8.00505682432E11 * param1.transform.rotation.x - 4.7073610762607E13 * param1.transform.rotation.w + 4.4331471276077E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2171</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.536187066657071E15 * param0.transform.rotation.y + 5.14908408201673E14 * param0.transform.rotation.z + 1.3544753423870126E19 * param1.transform.rotation.w - 1.2756135240175446E19 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>8.536187066657071E15 * param0.transform.rotation.y + 5.14908408201673E14 * param0.transform.rotation.z + 1.3544753423870126E19 * param1.transform.rotation.w - 1.2756135240175446E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.953454767220368E15 * param0.transform.rotation.y - 5.14908408201673E14 * param0.transform.rotation.x + 6.6458289474056294E18 * param1.transform.rotation.w - 6.2588566270230559E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>3.953454767220368E15 * param0.transform.rotation.y - 5.14908408201673E14 * param0.transform.rotation.x + 6.6458289474056294E18 * param1.transform.rotation.w - 6.2588566270230559E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.508666929738145E15 * param0.transform.rotation.y + 1.5687970795992896E17 * param0.transform.rotation.w + 1.6367009645107366E19 * param1.transform.rotation.w - 1.5570601442859692E19 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>4.508666929738145E15 * param0.transform.rotation.y + 1.5687970795992896E17 * param0.transform.rotation.w + 1.6367009645107366E19 * param1.transform.rotation.w - 1.5570601442859692E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.893995707616361E15 * param0.transform.rotation.y + 1.06014174872040013E18 * param1.transform.rotation.y + 8.0013679388017449E18 * param1.transform.rotation.w - 7.5312345246131405E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>4.893995707616361E15 * param0.transform.rotation.y + 1.06014174872040013E18 * param1.transform.rotation.y + 8.0013679388017449E18 * param1.transform.rotation.w - 7.5312345246131405E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.311062431130753E15 * param0.transform.rotation.y - 1.32517718590050016E17 * param1.transform.rotation.x + 7.7926836010768814E18 * param1.transform.rotation.w - 7.3386848199923149E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>4.311062431130753E15 * param0.transform.rotation.y - 1.32517718590050016E17 * param1.transform.rotation.x + 7.7926836010768814E18 * param1.transform.rotation.w - 7.3386848199923149E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.953454767220368E15 * param0.transform.rotation.z + 8.536187066657071E15 * param0.transform.rotation.x - 6.1787088013316844E18 * param1.transform.rotation.w + 5.8184470623411098E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>3.953454767220368E15 * param0.transform.rotation.z + 8.536187066657071E15 * param0.transform.rotation.x - 6.1787088013316844E18 * param1.transform.rotation.w + 5.8184470623411098E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.893995707616361E15 * param0.transform.rotation.x - 4.6420200321055757E17 * param1.transform.rotation.y - 3.5035418896573332E18 * param1.transform.rotation.w + 3.2975257564724695E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>4.893995707616361E15 * param0.transform.rotation.x - 4.6420200321055757E17 * param1.transform.rotation.y - 3.5035418896573332E18 * param1.transform.rotation.w + 3.2975257564724695E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.311062431130753E15 * param0.transform.rotation.x + 5.8025250401319696E16 * param1.transform.rotation.x - 3.4121657244157742E18 * param1.transform.rotation.w + 3.2132334649461627E18 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>4.311062431130753E15 * param0.transform.rotation.x + 5.8025250401319696E16 * param1.transform.rotation.x - 3.4121657244157742E18 * param1.transform.rotation.w + 3.2132334649461627E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.78081301765852E14 * param1.transform.rotation.y - 7.959602722188443E15 * param1.transform.rotation.z - 2.2311522786182512E16 * param1.transform.rotation.w + 2.3690874244868344E16 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>5.78081301765852E14 * param1.transform.rotation.y - 7.959602722188443E15 * param1.transform.rotation.z - 2.2311522786182512E16 * param1.transform.rotation.w + 2.3690874244868344E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.619050518097055E15 * param1.transform.rotation.y + 1.560368128552953E15 * param1.transform.rotation.x - 2.6705340650812744E16 * param1.transform.rotation.w + 2.5181977086241956E16 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>8.619050518097055E15 * param1.transform.rotation.y + 1.560368128552953E15 * param1.transform.rotation.x - 2.6705340650812744E16 * param1.transform.rotation.w + 2.5181977086241956E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.447620207238822E16 * param1.transform.rotation.z + 2.64229750886011E14 * param1.transform.rotation.x + 9.5304740376184576E16 * param1.transform.rotation.w - 1.01347523410916848E17 == 0</INV> <SAMPLES>2171</SAMPLES> <DAIKON>3.447620207238822E16 * param1.transform.rotation.z + 2.64229750886011E14 * param1.transform.rotation.x + 9.5304740376184576E16 * param1.transform.rotation.w - 1.01347523410916848E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2171</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</INV> <SAMPLES>2171</SAMPLES> <DAIKON>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data &lt; orig(param2.data)</INV> <SAMPLES>2171</SAMPLES> <DAIKON>return.data &lt; orig(param2.data)</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 has only one value</INV> <SAMPLES>12</SAMPLES> <DAIKON>param0 has only one value</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>12</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.data == true</INV> <SAMPLES>12</SAMPLES> <DAIKON>param0.data == true</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>12</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;no&quot;, &quot;y&quot; }</INV> <SAMPLES>12</SAMPLES> <DAIKON>return.data one of { &quot;no&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt;= 0.0178672092569</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &gt;= 0.0178672092569</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.LowerBoundFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt;= 0.0347773804432</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &gt;= 0.0347773804432</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.LowerBoundFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &lt;= 0.99897785038</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &lt;= 0.99897785038</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.UpperBoundFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z one of { 0.336192066889, 0.336238484973 }</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z one of { 0.336192066889, 0.336238484973 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z == 1.05235948185</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z == 1.05235948185</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.941783160825</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.941783160825</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs &lt;= param1.header.stamp.secs</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.header.stamp.secs &lt;= param1.header.stamp.secs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param0.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y &lt; param1.transform.translation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.6111004933888E13 * param1.transform.rotation.y - 1.26101399692434E14 * param1.transform.rotation.w + 1.18903791116621E14 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.6111004933888E13 * param1.transform.rotation.y - 1.26101399692434E14 * param1.transform.rotation.w + 1.18903791116621E14 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.01398901462E11 * param1.transform.rotation.z + 8.36193863223E11 * param1.transform.rotation.w - 8.88841219209E11 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.01398901462E11 * param1.transform.rotation.z + 8.36193863223E11 * param1.transform.rotation.w - 8.88841219209E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.3805134800661E13 * param1.transform.translation.z + 1.129998182504E12 * param1.transform.translation.x - 2.4904030147535E13 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.3805134800661E13 * param1.transform.translation.z + 1.129998182504E12 * param1.transform.translation.x - 2.4904030147535E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.934600628193E12 * param1.transform.translation.z - 1.129998182504E12 * param1.transform.translation.y - 7.24145997537E12 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>6.934600628193E12 * param1.transform.translation.z - 1.129998182504E12 * param1.transform.translation.y - 7.24145997537E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.7158118774272E13 * param1.transform.rotation.x - 1.49308739050847E14 * param1.transform.rotation.w + 1.404719457075E14 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>7.7158118774272E13 * param1.transform.rotation.x - 1.49308739050847E14 * param1.transform.rotation.w + 1.404719457075E14 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2312</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.2630594697641E13 * param0.transform.rotation.y - 7.996489352665739E15 * param0.transform.rotation.x - 1.99071111718939392E18 * param1.transform.rotation.w + 1.87512726735104589E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.2630594697641E13 * param0.transform.rotation.y - 7.996489352665739E15 * param0.transform.rotation.x - 1.99071111718939392E18 * param1.transform.rotation.w + 1.87512726735104589E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.16928030116789E14 * param0.transform.rotation.y - 1.4234111937657192E17 * param1.transform.rotation.y + 4.9706216761442477E17 * param1.transform.rotation.w - 4.6867851698381626E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>9.16928030116789E14 * param0.transform.rotation.y - 1.4234111937657192E17 * param1.transform.rotation.y + 4.9706216761442477E17 * param1.transform.rotation.w - 4.6867851698381626E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.342549681179E12 * param0.transform.rotation.y + 1.5206961167970288E17 * param1.transform.rotation.z + 4.2189827319362118E17 * param1.transform.rotation.w - 4.4846126823295162E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.342549681179E12 * param0.transform.rotation.y + 1.5206961167970288E17 * param1.transform.rotation.z + 4.2189827319362118E17 * param1.transform.rotation.w - 4.4846126823295162E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.2630594697641E13 * param0.transform.rotation.z + 2.6045176132089396E16 * param0.transform.rotation.x + 6.4767070383843942E18 * param1.transform.rotation.w - 6.1006609749704796E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>5.2630594697641E13 * param0.transform.rotation.z + 2.6045176132089396E16 * param0.transform.rotation.x + 6.4767070383843942E18 * param1.transform.rotation.w - 6.1006609749704796E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.16928030116789E14 * param0.transform.rotation.z + 5.291131405622855E17 * param1.transform.rotation.y - 1.84768902839226419E18 * param1.transform.rotation.w + 1.74217393184094464E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>9.16928030116789E14 * param0.transform.rotation.z + 5.291131405622855E17 * param1.transform.rotation.y - 1.84768902839226419E18 * param1.transform.rotation.w + 1.74217393184094464E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.342549681179E12 * param0.transform.rotation.z - 5.6527607884737587E17 * param1.transform.rotation.z - 1.56828835760879949E18 * param1.transform.rotation.w + 1.66702882250620467E18 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.342549681179E12 * param0.transform.rotation.z - 5.6527607884737587E17 * param1.transform.rotation.z - 1.56828835760879949E18 * param1.transform.rotation.w + 1.66702882250620467E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.691380126623311E15 * param0.transform.translation.z - 1.8500533438881687E20 * param1.transform.translation.z - 8.7819578995663985E18 * param1.transform.translation.x + 1.9354543376595517E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.691380126623311E15 * param0.transform.translation.z - 1.8500533438881687E20 * param1.transform.translation.z - 8.7819578995663985E18 * param1.transform.translation.x + 1.9354543376595517E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.643162689922823E15 * param0.transform.translation.z - 2.1557334059475642E20 * param1.transform.translation.z + 3.5127831598265594E19 * param1.transform.translation.y + 2.2511242638934665E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.643162689922823E15 * param0.transform.translation.z - 2.1557334059475642E20 * param1.transform.translation.z + 3.5127831598265594E19 * param1.transform.translation.y + 2.2511242638934665E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.691380126623311E15 * param0.transform.translation.x - 1.493895868998064E20 * param1.transform.translation.z - 7.0913255940528097E18 * param1.transform.translation.x + 1.562901892413708E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.691380126623311E15 * param0.transform.translation.x - 1.493895868998064E20 * param1.transform.translation.z - 7.0913255940528097E18 * param1.transform.translation.x + 1.562901892413708E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.643162689922823E15 * param0.transform.translation.x - 1.740728850033018E20 * param1.transform.translation.z + 2.836530237621124E19 * param1.transform.translation.y + 1.8178009713190112E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.643162689922823E15 * param0.transform.translation.x - 1.740728850033018E20 * param1.transform.translation.z + 2.836530237621124E19 * param1.transform.translation.y + 1.8178009713190112E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.691380126623311E15 * param0.transform.translation.y - 1.2368754499307512E20 * param1.transform.translation.z - 5.871283746592172E18 * param1.transform.translation.x + 1.2940106231086862E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.691380126623311E15 * param0.transform.translation.y - 1.2368754499307512E20 * param1.transform.translation.z - 5.871283746592172E18 * param1.transform.translation.x + 1.2940106231086862E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.643162689922823E15 * param0.transform.translation.y - 1.4412415378295815E20 * param1.transform.translation.z + 2.348513498636869E19 * param1.transform.translation.y + 1.50505504157149E20 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>3.643162689922823E15 * param0.transform.translation.y - 1.4412415378295815E20 * param1.transform.translation.z + 2.348513498636869E19 * param1.transform.translation.y + 1.50505504157149E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.368351392710231E15 * param0.transform.rotation.x - 1.05261189395282E14 * param0.transform.rotation.w + 5.8994745984258867E17 * param1.transform.rotation.w - 5.5558891002434874E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.368351392710231E15 * param0.transform.rotation.x - 1.05261189395282E14 * param0.transform.rotation.w + 5.8994745984258867E17 * param1.transform.rotation.w - 5.5558891002434874E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.16928030116789E14 * param0.transform.rotation.x - 1.20275349712621936E17 * param1.transform.rotation.y + 4.2000741809944493E17 * param1.transform.rotation.w - 3.9606961568410432E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>9.16928030116789E14 * param0.transform.rotation.x - 1.20275349712621936E17 * param1.transform.rotation.y + 4.2000741809944493E17 * param1.transform.rotation.w - 3.9606961568410432E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.342549681179E12 * param0.transform.rotation.x + 1.28495727766837344E17 * param1.transform.rotation.z + 3.564954566450185E17 * param1.transform.rotation.w - 3.7894071405275661E17 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.342549681179E12 * param0.transform.rotation.x + 1.28495727766837344E17 * param1.transform.rotation.z + 3.564954566450185E17 * param1.transform.rotation.w - 3.7894071405275661E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.16928030116789E14 * param0.transform.rotation.w - 1.948129977133754E16 * param1.transform.rotation.y + 6.802965393766068E16 * param1.transform.rotation.w - 6.5061300723201744E16 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>9.16928030116789E14 * param0.transform.rotation.w - 1.948129977133754E16 * param1.transform.rotation.y + 6.802965393766068E16 * param1.transform.rotation.w - 6.5061300723201744E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.47516560393E11 * param0.transform.rotation.w + 6.93759166762786E15 * param1.transform.rotation.z + 1.9247487465540216E16 * param1.transform.rotation.w - 2.045976926484312E16 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>4.47516560393E11 * param0.transform.rotation.w + 6.93759166762786E15 * param1.transform.rotation.z + 1.9247487465540216E16 * param1.transform.rotation.w - 2.045976926484312E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.334048787608E12 * param1.transform.rotation.y - 2.540559792323441E15 * param1.transform.rotation.z - 7.052653926216892E15 * param1.transform.rotation.w + 7.496192067998939E15 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.334048787608E12 * param1.transform.rotation.y - 2.540559792323441E15 * param1.transform.rotation.z - 7.052653926216892E15 * param1.transform.rotation.w + 7.496192067998939E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.303173173888678E15 * param1.transform.rotation.y - 1.251329152566375E15 * param1.transform.rotation.x - 6.585485574015186E15 * param1.transform.rotation.w + 6.213586822228244E15 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>2.303173173888678E15 * param1.transform.rotation.y - 1.251329152566375E15 * param1.transform.rotation.x - 6.585485574015186E15 * param1.transform.rotation.w + 6.213586822228244E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.30268595296399E15 * param1.transform.rotation.z - 3.33512196902E11 * param1.transform.rotation.x + 3.614785956521455E15 * param1.transform.rotation.w - 3.842296602233278E15 == 0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>1.30268595296399E15 * param1.transform.rotation.z - 3.33512196902E11 * param1.transform.rotation.x + 3.614785956521455E15 * param1.transform.rotation.w - 3.842296602233278E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z == 0.0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return.linear.z == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>2312</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z one of { 1.05220247162, 1.05235948185, 1.05273396159 }</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.translation.z one of { 1.05220247162, 1.05235948185, 1.05273396159 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w == 0.941783160825</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.w == 0.941783160825</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.x</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>5.05764758528E11 * return.transform.rotation.y + 3.0340310538752E13 * return.transform.rotation.w - 2.8571943068045E13 == 0</INV> <SAMPLES>11587</SAMPLES> <DAIKON>5.05764758528E11 * return.transform.rotation.y + 3.0340310538752E13 * return.transform.rotation.w - 2.8571943068045E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>7.466557454E10 * return.transform.rotation.z + 2.07698178551E11 * return.transform.rotation.w - 2.20708620924E11 == 0</INV> <SAMPLES>11587</SAMPLES> <DAIKON>7.466557454E10 * return.transform.rotation.z + 2.07698178551E11 * return.transform.rotation.w - 2.20708620924E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>1.011529517056E12 * return.transform.rotation.x + 1.88081178653722E14 * return.transform.rotation.w - 1.77133361696985E14 == 0</INV> <SAMPLES>11587</SAMPLES> <DAIKON>1.011529517056E12 * return.transform.rotation.x + 1.88081178653722E14 * return.transform.rotation.w - 1.77133361696985E14 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>11587</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>1.09728147648681E14 * return.transform.rotation.y + 2.2906382174447184E16 * return.transform.rotation.z + 6.3343892944513464E16 * return.transform.rotation.w - 6.7356719099193848E16 == 0</INV> <SAMPLES>11587</SAMPLES> <DAIKON>1.09728147648681E14 * return.transform.rotation.y + 2.2906382174447184E16 * return.transform.rotation.z + 6.3343892944513464E16 * return.transform.rotation.w - 6.7356719099193848E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>5.978899736274967E17 * return.transform.rotation.z + 9.74796143894099E14 * return.transform.rotation.x + 1.66280672696444774E18 * return.transform.rotation.w - 1.76701107121516698E18 == 0</INV> <SAMPLES>11587</SAMPLES> <DAIKON>5.978899736274967E17 * return.transform.rotation.z + 9.74796143894099E14 * return.transform.rotation.x + 1.66280672696444774E18 * return.transform.rotation.w - 1.76701107121516698E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>11556</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
