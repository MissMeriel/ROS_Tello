<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z one of { 1.05205433948, 1.05218651382, 1.05249777063 }</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.translation.z one of { 1.05205433948, 1.05218651382, 1.05249777063 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.943236931927</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.943236931927</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param0.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.x != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.40310544893E11 * param1.transform.rotation.z + 6.80281919261E11 * param1.transform.rotation.w - 7.21473317835E11 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>2.40310544893E11 * param1.transform.rotation.z + 6.80281919261E11 * param1.transform.rotation.w - 7.21473317835E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.79955466983424E14 * param1.transform.rotation.x + 4.115712220415847E15 * param1.transform.rotation.w - 3.882328081975636E15 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>4.79955466983424E14 * param1.transform.rotation.x + 4.115712220415847E15 * param1.transform.rotation.w - 3.882328081975636E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2080</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1278283249097E13 * param0.transform.rotation.y - 2.5336034752664177E18 * param1.transform.rotation.z - 7.1722388860131277E18 * param1.transform.rotation.w + 7.6065204606644695E18 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>3.1278283249097E13 * param0.transform.rotation.y - 2.5336034752664177E18 * param1.transform.rotation.z - 7.1722388860131277E18 * param1.transform.rotation.w + 7.6065204606644695E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1278283249097E13 * param0.transform.rotation.z - 8.1631508994190899E17 * param1.transform.rotation.z - 2.310861541072448E18 * param1.transform.rotation.w + 2.450785758056066E18 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>3.1278283249097E13 * param0.transform.rotation.z - 8.1631508994190899E17 * param1.transform.rotation.z - 2.310861541072448E18 * param1.transform.rotation.w + 2.450785758056066E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.20759720055959E14 * param0.transform.rotation.x + 1.0496170942267028E16 * param0.transform.rotation.w - 1.4306461716190304E17 * param1.transform.rotation.w + 1.2443564993222232E17 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>6.20759720055959E14 * param0.transform.rotation.x + 1.0496170942267028E16 * param0.transform.rotation.w - 1.4306461716190304E17 * param1.transform.rotation.w + 1.2443564993222232E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1278283249097E13 * param0.transform.rotation.x - 1.67361478806385178E18 * param1.transform.rotation.z - 4.7377441578129971E18 * param1.transform.rotation.w + 5.0246147215452058E18 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>3.1278283249097E13 * param0.transform.rotation.x - 1.67361478806385178E18 * param1.transform.rotation.z - 4.7377441578129971E18 * param1.transform.rotation.w + 5.0246147215452058E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1278283249097E13 * param0.transform.rotation.w + 1.03396907846447712E17 * param1.transform.rotation.z + 2.9270062596193261E17 * param1.transform.rotation.w - 3.1045497813633235E17 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>3.1278283249097E13 * param0.transform.rotation.w + 1.03396907846447712E17 * param1.transform.rotation.z + 2.9270062596193261E17 * param1.transform.rotation.w - 3.1045497813633235E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.552085952125E13 * param1.transform.rotation.y - 3.343248389960325E15 * param1.transform.rotation.z - 9.462802601268528E15 * param1.transform.rotation.w + 1.0036086974380552E16 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>3.552085952125E13 * param1.transform.rotation.y - 3.343248389960325E15 * param1.transform.rotation.z - 9.462802601268528E15 * param1.transform.rotation.w + 1.0036086974380552E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.099570108908196E16 * param1.transform.rotation.z - 8.916886916589E12 * param1.transform.rotation.x + 3.1050843696737924E16 * param1.transform.rotation.w - 3.2939931842211576E16 == 0</INV> <SAMPLES>2080</SAMPLES> <DAIKON>1.099570108908196E16 * param1.transform.rotation.z - 8.916886916589E12 * param1.transform.rotation.x + 3.1050843696737924E16 * param1.transform.rotation.w - 3.2939931842211576E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2080</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.943236931927</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.943236931927</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param0.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.x != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.5730024395E11 * param1.transform.rotation.z + 1.297216044034E12 * param1.transform.rotation.w - 1.375449892723E12 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>4.5730024395E11 * param1.transform.rotation.z + 1.297216044034E12 * param1.transform.rotation.w - 1.375449892723E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2070</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.846581283833E12 * param0.transform.rotation.y + 4.4256925367298944E17 * param1.transform.rotation.z + 1.25542888738000896E18 * param1.transform.rotation.w - 1.33114280129688269E18 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>6.846581283833E12 * param0.transform.rotation.y + 4.4256925367298944E17 * param1.transform.rotation.z + 1.25542888738000896E18 * param1.transform.rotation.w - 1.33114280129688269E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.0539743851499E13 * param0.transform.rotation.z + 1.11630804914424528E17 * param1.transform.rotation.z + 3.1666125933502464E17 * param1.transform.rotation.w - 3.3575850870418227E17 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>2.0539743851499E13 * param0.transform.rotation.z + 1.11630804914424528E17 * param1.transform.rotation.z + 3.1666125933502464E17 * param1.transform.rotation.w - 3.3575850870418227E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.0539743851499E13 * param0.transform.rotation.x - 1.11252961480797888E18 * param1.transform.rotation.z - 3.1558943711162132E18 * param1.transform.rotation.w + 3.3462219174089713E18 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>2.0539743851499E13 * param0.transform.rotation.x - 1.11252961480797888E18 * param1.transform.rotation.z - 3.1558943711162132E18 * param1.transform.rotation.w + 3.3462219174089713E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.7428305938436E13 * param1.transform.rotation.y - 2.953070213234534E15 * param1.transform.rotation.z - 8.359412546414422E15 * param1.transform.rotation.w + 8.865759428936357E15 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>3.7428305938436E13 * param1.transform.rotation.y - 2.953070213234534E15 * param1.transform.rotation.z - 8.359412546414422E15 * param1.transform.rotation.w + 8.865759428936357E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.536171113429528E15 * param1.transform.rotation.z + 2.078032097941E12 * param1.transform.rotation.x + 1.0027095054514616E16 * param1.transform.rotation.w - 1.0632277496293506E16 == 0</INV> <SAMPLES>2070</SAMPLES> <DAIKON>3.536171113429528E15 * param1.transform.rotation.z + 2.078032097941E12 * param1.transform.rotation.x + 1.0027095054514616E16 * param1.transform.rotation.w - 1.0632277496293506E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2070</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</INV> <SAMPLES>2070</SAMPLES> <DAIKON>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data &lt; orig(param2.data)</INV> <SAMPLES>2070</SAMPLES> <DAIKON>return.data &lt; orig(param2.data)</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.data == true</INV> <SAMPLES>11</SAMPLES> <DAIKON>param0.data == true</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;no&quot;, &quot;y&quot; }</INV> <SAMPLES>11</SAMPLES> <DAIKON>return.data one of { &quot;no&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq one of { 201119, 205675, 207953 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.seq one of { 201119, 205675, 207953 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y one of { -0.0193489475652, 0.0304312055358, 0.06012958511 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y one of { -0.0193489475652, 0.0304312055358, 0.06012958511 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z one of { -0.0404800709009, -0.0139154449107, -4.98298731618E-4 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z one of { -0.0404800709009, -0.0139154449107, -4.98298731618E-4 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.secs one of { 1550024239, 1550024286, 1550024309 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.stamp.secs one of { 1550024239, 1550024286, 1550024309 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z one of { 0.038277608594, 0.567787591576, 0.574130297543 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z one of { 0.038277608594, 0.567787591576, 0.574130297543 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs one of { 474144125, 544093352, 574409426 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.stamp.nsecs one of { 474144125, 544093352, 574409426 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x one of { -1.32452715405, -0.653732279904, -0.351829913918 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.x one of { -1.32452715405, -0.653732279904, -0.351829913918 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y one of { -1.17306110997, 0.575820786534, 1.23434685526 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.y one of { -1.17306110997, 0.575820786534, 1.23434685526 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x one of { 0.0308892186852, 0.0681580253423, 0.0752501830867 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x one of { 0.0308892186852, 0.0681580253423, 0.0752501830867 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w one of { 0.995349986004, 0.99711322612, 0.998515316987 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.w one of { 0.995349986004, 0.99711322612, 0.998515316987 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z one of { 1.05203089266, 1.05218651382, 1.05245100042 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.translation.z one of { 1.05203089266, 1.05218651382, 1.05245100042 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x != 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.943236931927</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.943236931927</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &lt; param1.header.seq</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.seq &lt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &gt; param0.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y &gt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param0.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param0.transform.translation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &lt; param1.transform.translation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param0.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param0.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w &gt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param0.transform.rotation.w &gt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.7860384337408E13 * param1.transform.rotation.y - 2.43740913693412E14 * param1.transform.rotation.w + 2.29976293487579E14 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>1.7860384337408E13 * param1.transform.rotation.y - 2.43740913693412E14 * param1.transform.rotation.w + 2.29976293487579E14 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.39534252636E11 * param1.transform.rotation.z + 3.80279088648E11 * param1.transform.rotation.w - 4.05032118039E11 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>1.39534252636E11 * param1.transform.rotation.z + 3.80279088648E11 * param1.transform.rotation.w - 4.05032118039E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.20485499213824E14 * param1.transform.rotation.x - 8.872153798537613E15 * param1.transform.rotation.w + 8.368481420340034E15 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>1.20485499213824E14 * param1.transform.rotation.x - 8.872153798537613E15 * param1.transform.rotation.w + 8.368481420340034E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>2079</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.903583053679105E15 * param0.transform.rotation.y - 1.3624077704869666E16 * param0.transform.rotation.z + 5.714949120820265E17 * param1.transform.rotation.w - 5.3945477694174246E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>6.903583053679105E15 * param0.transform.rotation.y - 1.3624077704869666E16 * param0.transform.rotation.z + 5.714949120820265E17 * param1.transform.rotation.w - 5.3945477694174246E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915551067196193E15 * param0.transform.rotation.y - 1.3624077704869666E16 * param0.transform.rotation.x + 3.5595992835497149E18 * param1.transform.rotation.w - 3.3568577966329615E18 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>7.915551067196193E15 * param0.transform.rotation.y - 1.3624077704869666E16 * param0.transform.rotation.x + 3.5595992835497149E18 * param1.transform.rotation.w - 3.3568577966329615E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915551067196193E15 * param0.transform.rotation.z - 6.903583053679105E15 * param0.transform.rotation.x + 1.47168069390909491E18 * param1.transform.rotation.w - 1.38756289949547443E18 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>7.915551067196193E15 * param0.transform.rotation.z - 6.903583053679105E15 * param0.transform.rotation.x + 1.47168069390909491E18 * param1.transform.rotation.w - 1.38756289949547443E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.094178704999703E15 * param0.transform.rotation.z + 2.761433221471642E16 * param0.transform.rotation.w - 5.2942934386508416E17 * param1.transform.rotation.w + 4.7187183552606387E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>2.094178704999703E15 * param0.transform.rotation.z + 2.761433221471642E16 * param0.transform.rotation.w - 5.2942934386508416E17 * param1.transform.rotation.w + 4.7187183552606387E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.094178704999703E15 * param0.transform.rotation.x + 3.1662204268784772E16 * param0.transform.rotation.w - 1.05346561648216141E18 * param1.transform.rotation.w + 9.6195413825145446E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>2.094178704999703E15 * param0.transform.rotation.x + 3.1662204268784772E16 * param0.transform.rotation.w - 1.05346561648216141E18 * param1.transform.rotation.w + 9.6195413825145446E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.947703946087279E15 * param0.transform.rotation.w + 1.6510954321160246E16 * param1.transform.rotation.y - 2.25325223475780512E17 * param1.transform.rotation.w + 2.07667159380122368E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>4.947703946087279E15 * param0.transform.rotation.w + 1.6510954321160246E16 * param1.transform.rotation.y - 2.25325223475780512E17 * param1.transform.rotation.w + 2.07667159380122368E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.713346598565107E15 * param0.transform.rotation.w + 1.740348339077879E15 * param1.transform.rotation.x - 1.28153497541858832E17 * param1.transform.rotation.w + 1.18172706715138016E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>2.713346598565107E15 * param0.transform.rotation.w + 1.740348339077879E15 * param1.transform.rotation.x - 1.28153497541858832E17 * param1.transform.rotation.w + 1.18172706715138016E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.23205412060577E14 * param1.transform.rotation.y - 3.6403827247464832E16 * param1.transform.rotation.z - 1.03623806260287536E17 * param1.transform.rotation.w + 1.09832667105525392E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>3.23205412060577E14 * param1.transform.rotation.y - 3.6403827247464832E16 * param1.transform.rotation.z - 1.03623806260287536E17 * param1.transform.rotation.w + 1.09832667105525392E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.128969451082236E15 * param1.transform.rotation.y + 9.53234429753907E14 * param1.transform.rotation.x - 1.53593505420233792E17 * param1.transform.rotation.w + 1.44902863109193152E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>7.128969451082236E15 * param1.transform.rotation.y + 9.53234429753907E14 * param1.transform.rotation.x - 1.53593505420233792E17 * param1.transform.rotation.w + 1.44902863109193152E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.51990514186508352E17 * param1.transform.rotation.z - 1.98166066089551E14 * param1.transform.rotation.x + 4.3397889947856845E17 * param1.transform.rotation.w - 4.5982034224463834E17 == 0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>1.51990514186508352E17 * param1.transform.rotation.z - 1.98166066089551E14 * param1.transform.rotation.x + 4.3397889947856845E17 * param1.transform.rotation.w - 4.5982034224463834E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>2079</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>2079</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>2079</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z one of { -200.0, 0.0 }</INV> <SAMPLES>2079</SAMPLES> <DAIKON>return.linear.z one of { -200.0, 0.0 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>2079</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w == 0.943236931927</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.w == 0.943236931927</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.x</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>2.83372883666E11 * return.transform.rotation.z + 8.02726146218E11 * return.transform.rotation.w - 8.51268090715E11 == 0</INV> <SAMPLES>10688</SAMPLES> <DAIKON>2.83372883666E11 * return.transform.rotation.z + 8.02726146218E11 * return.transform.rotation.w - 8.51268090715E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>10688</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>1.2236774141994E13 * return.transform.rotation.y - 1.68828932973561E15 * return.transform.rotation.z - 4.780839192049007E15 * return.transform.rotation.w + 5.070187621973182E15 == 0</INV> <SAMPLES>10688</SAMPLES> <DAIKON>1.2236774141994E13 * return.transform.rotation.y - 1.68828932973561E15 * return.transform.rotation.z - 4.780839192049007E15 * return.transform.rotation.w + 5.070187621973182E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>2.466435786024782E15 * return.transform.rotation.z - 6.118387070997E12 * return.transform.rotation.x + 6.935887019546152E15 * return.transform.rotation.w - 7.361276355426609E15 == 0</INV> <SAMPLES>10688</SAMPLES> <DAIKON>2.466435786024782E15 * return.transform.rotation.z - 6.118387070997E12 * return.transform.rotation.x + 6.935887019546152E15 * return.transform.rotation.w - 7.361276355426609E15 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.x</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.x</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != return.transform.translation.y</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.translation.x != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>10629</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
