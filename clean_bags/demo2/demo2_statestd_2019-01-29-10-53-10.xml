<root>
<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data &lt; orig(param2.data)</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data &lt; orig(param2.data)</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.data == true</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0.data == true</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;no&quot;, &quot;y&quot; }</INV> <SAMPLES>30</SAMPLES> <DAIKON>return.data one of { &quot;no&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z one of { -200.0, 0.0 }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.linear.z one of { -200.0, 0.0 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w == 0.997787593551</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &gt; return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data &lt; orig(param2.data)</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data &lt; orig(param2.data)</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.data == true</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0.data == true</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;no&quot;, &quot;y&quot; }</INV> <SAMPLES>30</SAMPLES> <DAIKON>return.data one of { &quot;no&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z one of { -200.0, 0.0 }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.linear.z one of { -200.0, 0.0 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w == 0.997787593551</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &gt; return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
<INVARIANTS>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..main():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return == 0</INV> <SAMPLES>1</SAMPLES> <DAIKON>return == 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>main()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.91990253568E11 * param1.transform.rotation.y - 2.7134107465453E13 * param1.transform.rotation.w + 2.7072962646666E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.3721340616E10 * param1.transform.rotation.z + 1.448414363901E12 * param1.transform.rotation.w - 1.450738224475E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.49304487808E11 * param1.transform.rotation.x + 3.2986029919137E13 * param1.transform.rotation.w - 3.2912294023251E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1045</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>2.371597380660418E15 * param0.transform.rotation.y + 3.28009980904493E14 * param0.transform.rotation.z - 2.19146905189904384E18 * param1.transform.rotation.w + 2.18659785250691251E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.y + 4.1985277555775104E16 * param0.transform.rotation.x - 3.4603079082616324E19 * param1.transform.rotation.w + 3.452448185834821E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>5.270310779343045E15 * param0.transform.rotation.y - 6.56019961808986E14 * param0.transform.rotation.w - 4.8284436879921152E18 * param1.transform.rotation.w + 4.8183964008995062E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.y - 9.8375805614656208E16 * param1.transform.rotation.y + 1.3903516620978663E19 * param1.transform.rotation.w - 1.3871956427656894E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.y + 6.8638103671827648E17 * param1.transform.rotation.z + 1.1874680283153713E19 * param1.transform.rotation.w - 1.189355785013336E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.y + 1.53007238617905888E17 * param1.transform.rotation.x + 3.3804083353376236E19 * param1.transform.rotation.w - 3.372793445297703E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.369208901284791E15 * param0.transform.rotation.z - 3.035644647245335E17 * param0.transform.rotation.x + 2.2099810934648852E20 * param1.transform.rotation.w - 2.2049471709299032E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.z + 7.6229253939104563E17 * param1.transform.rotation.y - 1.0773530061839154E20 * param1.transform.rotation.w + 1.0749074122127922E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.z - 5.3186160987522601E18 * param1.transform.rotation.z - 9.201429285325663E19 * param1.transform.rotation.w + 9.216056613222144E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.z - 1.18561953055943731E18 * param1.transform.rotation.x - 2.6194042712258806E20 * param1.transform.rotation.w + 2.6135034975356132E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.3729988987795488E17 * param0.transform.rotation.x + 4.369208901284791E15 * param0.transform.rotation.w - 2.4583474731764803E20 * param1.transform.rotation.w + 2.4527023232778902E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.x + 1.6530014614875338E16 * param1.transform.rotation.y - 2.3361977216550456E18 * param1.transform.rotation.w + 2.3308215653020047E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.x - 1.15332103228398496E17 * param1.transform.rotation.z - 1.99529383674251136E18 * param1.transform.rotation.w + 1.99841028599385933E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.x - 2.5709694316941844E16 * param1.transform.rotation.x - 5.6800753842113884E18 * param1.transform.rotation.w + 5.6670940327020186E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.806110509916397E15 * param0.transform.rotation.w - 8.4652301918588326E17 * param1.transform.rotation.y + 1.1963964913684532E20 * param1.transform.rotation.w - 1.1936995384369488E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>1.371734597068871E15 * param0.transform.rotation.w + 5.9063033220856074E18 * param1.transform.rotation.z + 1.0218152870368733E20 * param1.transform.rotation.w - 1.0234539780709042E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.596963273883911E15 * param0.transform.rotation.w + 1.31662606250441523E18 * param1.transform.rotation.x + 2.9088386643766454E20 * param1.transform.rotation.w - 2.9023339057879682E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>8.158031807940601E15 * param1.transform.rotation.y + 2.9269892316171949E17 * param1.transform.rotation.z + 4.9234971701683999E18 * param1.transform.rotation.w - 4.931979378004436E18 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>3.368647867856935E15 * param1.transform.rotation.y - 6.749085688333773E15 * param1.transform.rotation.x - 9.3758274777761792E17 * param1.transform.rotation.w + 9.3545449434459315E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</INV> <SAMPLES>1045</SAMPLES> <DAIKON>4.933628545182935E15 * param1.transform.rotation.z - 3.79339434919589E14 * param1.transform.rotation.x + 7.3009460620271312E16 * param1.transform.rotation.w - 7.317563802849656E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1045</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>obstacle_detector(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param2.data one of { &quot;no&quot;, &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.02871526656E11 * param1.transform.rotation.y + 4.7817151234027E13 * param1.transform.rotation.w - 4.7712536493475E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>8.0865481984E10 * param1.transform.rotation.z + 1.586001537479E12 * param1.transform.rotation.w - 1.587832419394E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.175831207808E12 * param1.transform.rotation.x - 5.6281227741513E13 * param1.transform.rotation.w + 5.6162731696546E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1005</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.078617598287678E15 * param0.transform.rotation.y - 1.35272621890743E14 * param0.transform.rotation.z - 3.377124255926042E20 * param1.transform.rotation.w + 3.369659206303138E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.021360441289921E15 * param0.transform.rotation.y - 5.41090487562972E14 * param0.transform.rotation.x - 2.1198246317288535E20 * param1.transform.rotation.w + 2.1151388933549615E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.y - 8.07057725449487E14 * param0.transform.rotation.w + 1.9768282927271857E20 * param1.transform.rotation.w - 1.9724512331156233E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.y - 3.7382305907750758E17 * param1.transform.rotation.y - 8.811070752666968E19 * param1.transform.rotation.w + 8.79181113231655E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.y - 4.7682404481010555E18 * param1.transform.rotation.z - 9.351872388832269E19 * param1.transform.rotation.w + 9.362670294406711E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.y + 8.666624169628629E18 * param1.transform.rotation.x - 4.148284595628941E20 * param1.transform.rotation.w + 4.1395559036252534E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.784249572722017E15 * param0.transform.rotation.z + 4.6023816091361408E16 * param0.transform.rotation.x + 2.3028393508637822E21 * param1.transform.rotation.w - 2.2977511214242356E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.099122410191273E15 * param0.transform.rotation.z + 2.876488505710088E15 * param0.transform.rotation.w - 5.61624175977431E19 * param1.transform.rotation.w + 5.60352522955557E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.z + 1.6224810379128041E18 * param1.transform.rotation.y + 3.824214390409287E20 * param1.transform.rotation.w - 3.8158612050495085E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.z + 2.0695298279202116E19 * param1.transform.rotation.z + 4.058935170372862E20 * param1.transform.rotation.w - 4.06362243786879E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.z - 3.761521135865455E19 * param1.transform.rotation.x + 1.8004542343863953E21 * param1.transform.rotation.w - 1.7966675682697573E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.9585958563060368E16 * param0.transform.rotation.x - 3.784249572722017E15 * param0.transform.rotation.w + 2.554960198707736E21 * param1.transform.rotation.w - 2.549310855387746E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.x - 6.4026144679275592E16 * param1.transform.rotation.y - 1.5091067206547626E19 * param1.transform.rotation.w + 1.5057966636612104E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.x - 8.1667528361965901E17 * param1.transform.rotation.z - 1.6017319425588222E19 * param1.transform.rotation.w + 1.6035799649950312E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.x + 1.48436678661521408E18 * param1.transform.rotation.x - 7.104930079647126E19 * param1.transform.rotation.w + 7.089945766070279E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.361710540516333E15 * param0.transform.rotation.w - 1.77513062919369088E18 * param1.transform.rotation.y - 4.184011978193383E20 * param1.transform.rotation.w + 4.174858885226898E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.64716031002169E14 * param0.transform.rotation.w - 2.264239581065938E19 * param1.transform.rotation.z - 4.440816240360647E20 * param1.transform.rotation.w + 4.445942810766906E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>4.106819888475161E15 * param0.transform.rotation.w + 4.115420288192643E19 * param1.transform.rotation.x - 1.9698482652421171E21 * param1.transform.rotation.w + 1.9657011101008373E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>2.372373841255295E15 * param1.transform.rotation.y + 1.6319845075268128E16 * param1.transform.rotation.z + 2.45738991755843648E17 * param1.transform.rotation.w - 2.46286714656089568E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>1.764207407547607E15 * param1.transform.rotation.y + 2.775335428965734E15 * param1.transform.rotation.x - 6.9644716617453904E16 * param1.transform.rotation.w + 6.9494554663909096E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</INV> <SAMPLES>1005</SAMPLES> <DAIKON>3.1586375649486324E16 * param1.transform.rotation.z - 3.790009244946345E15 * param1.transform.rotation.x + 4.4210550292980115E17 * param1.transform.rotation.w - 4.4323237222868838E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data one of { &quot;AVOIDING&quot;, &quot;GO TO GOAL&quot;, &quot;GOAL REACHED&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data &lt; orig(param2.data)</INV> <SAMPLES>1005</SAMPLES> <DAIKON>return.data &lt; orig(param2.data)</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>state(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.data == true</INV> <SAMPLES>30</SAMPLES> <DAIKON>param0.data == true</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfScalar</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..user_input(std_msgs/Bool):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>30</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.data one of { &quot;no&quot;, &quot;y&quot; }</INV> <SAMPLES>30</SAMPLES> <DAIKON>return.data one of { &quot;no&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>user_input(std_msgs/Bool)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::ENTER</PPTNAME>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == param1.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == param1.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.w == 0.997787593551</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2 != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2 != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param2.data one of { &quot;nonsensical&quot;, &quot;y&quot; }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.seq &gt; param1.header.seq</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.seq &gt; param1.header.seq</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param0.header.frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param0.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.child_frame_id &gt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.child_frame_id &gt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.frame_id &lt; param1.child_frame_id</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.frame_id &lt; param1.child_frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.header.stamp.nsecs != param1.header.stamp.nsecs</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.header.stamp.nsecs != param1.header.stamp.nsecs</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.IntNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x &gt; param0.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x &gt; param0.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.x != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.x != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.translation.y != param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.translation.y != param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x != param0.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x != param0.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param0.transform.rotation.w != param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param0.transform.rotation.w != param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.567513230592E12 * param1.transform.rotation.y - 1.7655344603412E13 * param1.transform.rotation.w + 1.7607195486299E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.y &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.y &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &gt; param1.transform.rotation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &gt; param1.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>9.7969576912E10 * param1.transform.rotation.z + 1.53695789238E12 * param1.transform.rotation.w - 1.540026707459E12 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.z &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.z &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.z &gt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.z &gt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.translation.x &lt; param1.transform.translation.y</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.translation.x &lt; param1.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.02167242752E11 * param1.transform.rotation.x - 4.6869390001319E13 * param1.transform.rotation.w + 4.6769275646577E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>param1.transform.rotation.x &lt; param1.transform.rotation.w</INV> <SAMPLES>1044</SAMPLES> <DAIKON>param1.transform.rotation.x &lt; param1.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.2352477875273912E16 * param0.transform.rotation.y + 8.599003108755803E15 * param0.transform.rotation.z - 7.302230670866068E19 * param1.transform.rotation.w + 7.286017732754024E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.y + 3.4396012435023212E16 * param0.transform.rotation.x + 1.0749378569777439E20 * param1.transform.rotation.w - 1.0725762933606498E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.9199784347755672E16 * param0.transform.rotation.y - 8.599003108755803E15 * param0.transform.rotation.w - 5.743013226955984E19 * param1.transform.rotation.w + 5.7311414403860185E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.y - 1.3968641712849213E19 * param1.transform.rotation.y + 1.5733276011253003E20 * param1.transform.rotation.w - 1.5690281382116144E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.y + 1.117491337027937E20 * param1.transform.rotation.z + 1.7531331503596506E21 * param1.transform.rotation.w - 1.7566333588606815E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.y - 2.502900121052915E19 * param1.transform.rotation.x + 1.6706760834955438E21 * param1.transform.rotation.w - 1.6671064654970088E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>3.647143461167073E15 * param0.transform.rotation.z - 2.49409911501095648E17 * param0.transform.rotation.x - 8.104226309426309E20 * param1.transform.rotation.w + 8.08641465935816E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>8.649973043469459E15 * param0.transform.rotation.z + 7.794059734409239E15 * param0.transform.rotation.w - 2.1400981114952876E19 * param1.transform.rotation.w + 2.134549553907773E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.z + 9.893650018261983E19 * param1.transform.rotation.y - 1.114349767829387E21 * param1.transform.rotation.w + 1.1113039567260739E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.z - 7.914920014609587E20 * param1.transform.rotation.z - 1.241701675912881E22 * param1.transform.rotation.w + 1.2441807720432034E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.z + 1.7727434304213513E20 * param1.transform.rotation.x - 1.1832993360249967E22 * param1.transform.rotation.w + 1.1807709923904422E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.76799137391022688E17 * param0.transform.rotation.x + 3.647143461167073E15 * param0.transform.rotation.w + 8.894057396726922E20 * param1.transform.rotation.w - 8.87454937913687E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.x + 2.3466953120182303E18 * param1.transform.rotation.y - 2.6431492637064286E19 * param1.transform.rotation.w + 2.6358984659138245E19 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.x - 1.8773562496145842E19 * param1.transform.rotation.z - 2.9452178886572556E20 * param1.transform.rotation.w + 2.9510973840939024E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.x + 4.2048068103299482E18 * param1.transform.rotation.x - 2.8066921706736822E20 * param1.transform.rotation.w + 2.800692100788917E20 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>6.869143495872219E15 * param0.transform.rotation.w - 1.1056179619156622E20 * param1.transform.rotation.y + 1.2452887628878863E21 * param1.transform.rotation.w - 1.2418922854420597E21 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>1.885442268440767E15 * param0.transform.rotation.w + 8.844943695325297E20 * param1.transform.rotation.z + 1.3876048512894835E22 * param1.transform.rotation.w - 1.3903754459556268E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.915521707991783E15 * param0.transform.rotation.w - 1.9810453926751522E20 * param1.transform.rotation.x + 1.3223400846171612E22 * param1.transform.rotation.w - 1.3195154865190854E22 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>7.458709576311261E15 * param1.transform.rotation.y + 2.5054374471432768E16 * param1.transform.rotation.z + 3.0904632892361715E17 * param1.transform.rotation.w - 3.1006024454786694E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>2.411156977514558E15 * param1.transform.rotation.y + 7.57804879233799E14 * param1.transform.rotation.x - 6.1467046755478176E16 * param1.transform.rotation.w + 6.132094040317244E16 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>ENTER</PARENT> <INV>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>4.6072889493553456E16 * param1.transform.rotation.z - 4.427230850914271E15 * param1.transform.rotation.x + 7.2481654845825459E17 * param1.transform.rotation.w - 7.2627781580798438E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String):::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.x</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == return.angular.z</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == return.angular.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatEqual</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.linear.z one of { -200.0, 0.0 }</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.linear.z one of { -200.0, 0.0 }</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.angular.y == 0.0</INV> <SAMPLES>1044</SAMPLES> <DAIKON>return.angular.y == 0.0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>velocity(geometry_msgs/TransformStamped, geometry_msgs/TransformStamped, std_msgs/String)</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconOBSTACLEOBSTACLE():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/OBSTACLE/OBSTACLE&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w == 0.997787593551</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.w == 0.997787593551</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.OneOfFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.z</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>9.54479502208E11 * return.transform.rotation.y + 1.5839271296267E13 * return.transform.rotation.w - 1.5809768934632E13 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.y &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &gt; return.transform.rotation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &gt; return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>3.7763799768E10 * return.transform.rotation.z + 5.20429113056E11 * return.transform.rotation.w - 5.21771314415E11 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.LinearBinaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.z &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.x</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z &gt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.z &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &lt; return.transform.translation.y</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.translation.x &lt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x &lt; return.transform.rotation.w</INV> <SAMPLES>5480</SAMPLES> <DAIKON>return.transform.rotation.x &lt; return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatLessThan</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.618164649799257E15 * return.transform.rotation.y + 1.6507065298994884E16 * return.transform.rotation.z + 2.81694719291767168E17 * return.transform.rotation.w - 2.82188294662144352E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</INV> <SAMPLES>5480</SAMPLES> <DAIKON>4.126581829701984E16 * return.transform.rotation.z - 4.618164649799257E15 * return.transform.rotation.x + 5.86577017991392E17 * return.transform.rotation.w - 5.8802768648049037E17 == 0</DAIKON> <DAIKONCLASS>class daikon.inv.ternary.threeScalar.LinearTernaryFloat</DAIKONCLASS> <METHOD>viconOBSTACLEOBSTACLE()</METHOD> </INVINFO>
</PPT>
<!-- =========================================================================== -->
<PPT>
<PPTNAME>..viconTELLOTELLO():::EXIT</PPTNAME>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return != null</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return != null</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZero</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id == &quot;vicon/TELLO/TELLO&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.header.frame_id == &quot;/world&quot;</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.header.frame_id == &quot;/world&quot;</DAIKON> <DAIKONCLASS>class daikon.inv.unary.string.OneOfString</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.y != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.y != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.w != 0</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.w != 0</DAIKON> <DAIKONCLASS>class daikon.inv.unary.scalar.NonZeroFloat</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.z</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.z</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.x</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.x</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.y != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.y != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.child_frame_id &gt; return.header.frame_id</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.child_frame_id &gt; return.header.frame_id</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoString.StringGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.z != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.z != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.z != return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.z != return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.translation.x &gt; return.transform.translation.y</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.translation.x &gt; return.transform.translation.y</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatGreaterThan</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
<INVINFO> <PARENT>EXIT</PARENT> <INV>return.transform.rotation.x != return.transform.rotation.w</INV> <SAMPLES>5438</SAMPLES> <DAIKON>return.transform.rotation.x != return.transform.rotation.w</DAIKON> <DAIKONCLASS>class daikon.inv.binary.twoScalar.FloatNonEqual</DAIKONCLASS> <METHOD>viconTELLOTELLO()</METHOD> </INVINFO>
</PPT>
</INVARIANTS>
</root>
